{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"NATS Connect Opts","text":"<p>This is not an official NATS project</p> <p>This is a personal project and is not endorsed by the NATS.io community. It is not guaranteed to be maintained or supported.</p> <p>This is an experimental project</p> <p>This project is a prototype and should not be used for anything serious. It is not well tested, nor is it guaranteed to be correct.</p> <p>The nats.go package (Go client for NATS) provides a simple way to configure connect options using the Options pattern</p> <p>This project is an attempt to implement the same API in Python.</p> <p>Note: This may not be Pythonic and may not be the best way to do it in Python. This is just an experiment.</p>"},{"location":"#references","title":"References","text":"<ul> <li>The nats.aio.Client.connect method from nats-py.</li> </ul>"},{"location":"#how-to-install","title":"How to install","text":"pip install nats-connect-opts"},{"location":"#example-usage","title":"Example usage","text":"examples/minimal.py<pre><code>from __future__ import annotations\n\nfrom nats_contrib.connect_opts import connect, option\n\n\nasync def main() -&gt; None:\n    \"\"\"A simple example of using the connect function.\"\"\"\n\n    client = await connect(\n        # Configure the servers\n        option.WithServers(\n            [\n                \"nats://localhost:4222\",\n                \"nats://localhost:4223\",\n            ]\n        ),\n        # Configure the reconnect strategy\n        option.WithAllowReconnect(\n            max_attempts=10,\n            delay_seconds=0.5,\n        ),\n        # Configure the connection name\n        option.WithConnectionName(\"my-connection\"),\n        # Configure the flusher\n        option.WithFlusher(\n            queue_size=100,\n            timeout_seconds=10,\n        ),\n    )\n\n    # Close the client\n    await client.close()\n</code></pre>"},{"location":"#other-works","title":"Other works","text":"<ul> <li> <p>NATS Micro</p> </li> <li> <p>NATS Request Many</p> </li> </ul>"},{"location":"LICENSE/","title":"License","text":"<p>MIT License</p> <p>Copyright (c) 2024 Guillaume Charbonnier</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"SUMMARY/","title":"SUMMARY","text":"<ul> <li>Home</li> <li>Reference</li> <li>Coverage</li> <li>License</li> </ul>"},{"location":"reference/nats_contrib/connect_opts/","title":"Reference","text":""},{"location":"reference/nats_contrib/connect_opts/#nats_contrib.connect_opts.ConnectOption","title":"<code>ConnectOption</code>","text":"<p>Base class for connect options.</p> <p>A connect option is a callable which can transform a <code>ConnectOpts</code> object.</p> Source code in <code>src/nats_contrib/connect_opts/connect_opts.py</code> <pre><code>class ConnectOption(metaclass=abc.ABCMeta):\n    \"\"\"Base class for connect options.\n\n    A connect option is a callable which can transform a\n    [`ConnectOpts`][nats_contrib.connect_opts.ConnectOpts] object.\n    \"\"\"\n\n    @abc.abstractmethod\n    def __call__(self, opts: ConnectOpts) -&gt; None:\n        raise NotImplementedError\n</code></pre>"},{"location":"reference/nats_contrib/connect_opts/#nats_contrib.connect_opts.ConnectOpts","title":"<code>ConnectOpts</code>  <code>dataclass</code>","text":"<p>Connect options for NATS python client.</p> <p>Parameters:</p> Name Type Description Default <code>servers</code> <code>str | list[str]</code> <p>A single server URL or a list of server URLs.</p> <code>'nats://localhost:4222'</code> <code>name</code> <code>str | None</code> <p>The connection name.</p> <code>None</code> <code>dont_randomize</code> <code>bool</code> <p>Disable randomizing the server list.</p> <code>False</code> <code>inbox_prefix</code> <code>str | bytes</code> <p>The inbox prefix to use.</p> <code>b'_INBOX'</code> <code>pedantic</code> <code>bool</code> <p>Enable pedantic mode.</p> <code>False</code> <code>verbose</code> <code>bool</code> <p>Enable verbose logging.</p> <code>False</code> <code>no_echo</code> <code>bool</code> <p>Disable echo.</p> <code>False</code> <code>connect_timeout</code> <code>float</code> <p>The connection timeout in seconds.</p> <code>2</code> <code>drain_timeout</code> <code>float</code> <p>The drain timeout in seconds.</p> <code>30</code> <code>allow_reconnect</code> <code>bool</code> <p>Enable automatic reconnection.</p> <code>True</code> <code>max_reconnect_attempts</code> <code>int</code> <p>The maximum number of reconnection attempts. <code>-1</code> for infinite.</p> <code>-1</code> <code>reconnect_time_wait</code> <code>float</code> <p>The delay between reconnection attempts in seconds.</p> <code>2</code> <code>ping_interval</code> <code>float</code> <p>The ping interval in seconds.</p> <code>60</code> <code>max_outstanding_pings</code> <code>int</code> <p>The maximum number of outstanding pings before closing the connection.</p> <code>2</code> <code>pending_size</code> <code>int</code> <p>The maximum size of the pending queue in bytes.</p> <code>1024 * 1024 * 2</code> <code>flusher_queue_size</code> <code>int</code> <p>The size of the flusher queue in number of messages.</p> <code>1024</code> <code>flush_timeout</code> <code>float | None</code> <p>The flusher timeout in seconds.</p> <code>None</code> <code>tls</code> <code>SSLContext | None</code> <p>The TLS context to use.</p> <code>None</code> <code>tls_hostname</code> <code>str | None</code> <p>The hostname to use for TLS verification.</p> <code>None</code> <code>user</code> <code>str | None</code> <p>The username to use for authentication.</p> <code>None</code> <code>password</code> <code>str | None</code> <p>The password to use for authentication.</p> <code>None</code> <code>token</code> <code>str | None</code> <p>The token to use for authentication.</p> <code>None</code> <code>user_credentials</code> <code>str | tuple[str, str] | None</code> <p>The path to the credentials file to use for authentication.</p> <code>None</code> <code>nkeys_seed</code> <code>str | None</code> <p>The nkeys seed to use for authentication.</p> <code>None</code> <code>signature_cb</code> <code>Callable[[str], bytes] | None</code> <p>The callback function to sign the nonce during authentication.</p> <code>None</code> <code>user_jwt_cb</code> <code>Callable[[], bytearray | bytes] | None</code> <p>The callback function to return the jwt during authentication.</p> <code>None</code> <code>error_cb</code> <code>Callable[[Exception], Awaitable[None]] | None</code> <p>The callback function to call each time an error occurs.</p> <code>None</code> <code>disconnected_cb</code> <code>Callable[[], Awaitable[None]] | None</code> <p>The callback function to call each time connection is lost.</p> <code>None</code> <code>closed_cb</code> <code>Callable[[], Awaitable[None]] | None</code> <p>The callback function to call once connection is closed.</p> <code>None</code> <code>discovered_server_cb</code> <code>Callable[[], Awaitable[None]] | None</code> <p>The callback function to call each time a new server is discovered.</p> <code>None</code> <code>reconnected_cb</code> <code>Callable[[], Awaitable[None]] | None</code> <p>The callback function to call each time connection is reestablished.</p> <code>None</code> Source code in <code>src/nats_contrib/connect_opts/connect_opts.py</code> <pre><code>@dataclass\nclass ConnectOpts:\n    \"\"\"Connect options for NATS python client.\n\n    Args:\n        servers: A single server URL or a list of server URLs.\n        name: The connection name.\n        dont_randomize: Disable randomizing the server list.\n        inbox_prefix: The inbox prefix to use.\n        pedantic: Enable pedantic mode.\n        verbose: Enable verbose logging.\n        no_echo: Disable echo.\n        connect_timeout: The connection timeout in seconds.\n        drain_timeout: The drain timeout in seconds.\n        allow_reconnect: Enable automatic reconnection.\n        max_reconnect_attempts: The maximum number of reconnection attempts. `-1` for infinite.\n        reconnect_time_wait: The delay between reconnection attempts in seconds.\n        ping_interval: The ping interval in seconds.\n        max_outstanding_pings: The maximum number of outstanding pings before closing the connection.\n        pending_size: The maximum size of the pending queue in bytes.\n        flusher_queue_size: The size of the flusher queue in number of messages.\n        flush_timeout: The flusher timeout in seconds.\n        tls: The TLS context to use.\n        tls_hostname: The hostname to use for TLS verification.\n        user: The username to use for authentication.\n        password: The password to use for authentication.\n        token: The token to use for authentication.\n        user_credentials: The path to the credentials file to use for authentication.\n        nkeys_seed: The nkeys seed to use for authentication.\n        signature_cb: The callback function to sign the nonce during authentication.\n        user_jwt_cb: The callback function to return the jwt during authentication.\n        error_cb: The callback function to call each time an error occurs.\n        disconnected_cb: The callback function to call each time connection is lost.\n        closed_cb: The callback function to call once connection is closed.\n        discovered_server_cb: The callback function to call each time a new server is discovered.\n        reconnected_cb: The callback function to call each time connection is reestablished.\n    \"\"\"\n\n    servers: str | list[str] = \"nats://localhost:4222\"\n    name: str | None = None\n    dont_randomize: bool = False\n    inbox_prefix: str | bytes = b\"_INBOX\"  # Note: No trailing \".\" in inbox prefix\n    pedantic: bool = False\n    verbose: bool = False\n    no_echo: bool = False\n    # First connect\n    connect_timeout: float = 2  # seconds\n    # Drain\n    drain_timeout: float = 30  # seconds\n    # Reconnect\n    allow_reconnect: bool = True\n    max_reconnect_attempts: int = -1  # -1 for infinite\n    reconnect_time_wait: float = 2  # seconds\n    # PingPong\n    ping_interval: float = 60  # seconds\n    max_outstanding_pings: int = 2\n    # Pending queue\n    pending_size: int = 1024 * 1024 * 2  # bytes (2MiB)\n    # Flusher\n    flusher_queue_size: int = 1024\n    flush_timeout: float | None = None\n    # tls\n    tls: ssl.SSLContext | None = None\n    tls_hostname: str | None = None\n    # Auth\n    user: str | None = None\n    password: str | None = None\n    token: str | None = None\n    user_credentials: str | tuple[str, str] | None = None\n    nkeys_seed: str | None = None\n    signature_cb: Callable[[str], bytes] | None = None\n    user_jwt_cb: Callable[[], bytearray | bytes] | None = None\n    # Connection state callbacks\n    error_cb: Callable[[Exception], Awaitable[None]] | None = None\n    disconnected_cb: Callable[[], Awaitable[None]] | None = None\n    closed_cb: Callable[[], Awaitable[None]] | None = None\n    discovered_server_cb: Callable[[], Awaitable[None]] | None = None\n    reconnected_cb: Callable[[], Awaitable[None]] | None = None\n\n    def to_dict(self) -&gt; dict[str, Any]:\n        ctx = self.tls\n        self.tls = None\n        opts = asdict(self)\n        if ctx:\n            opts[\"tls\"] = ctx\n        return opts\n\n    @classmethod\n    def from_dict(cls, opts: dict[str, Any]) -&gt; ConnectOpts:\n        return cls(**opts)\n</code></pre>"}]}